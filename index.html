<!DOCTYPE html>
<html lang="en">
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>Terraform Workshop</title>

	<meta charset="utf-8">
	<meta name="description" content="Terraform Workshop">
	<meta name="author" content="Mike Branstein &amp; Eric Rhoads">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="css/style.css" rel="stylesheet">
</head>
<body>

<div id="container">
	<div id="header">
		<a href="#" class="menu header-btn" id="toggle-toc"></a>
		<h1>Terraform Workshop</h1>
		<a href="https://github.com/mikebranstein/terraform-workshop" class="github header-btn"></a>
	</div>

	<div id="content-container">
		<div id="toc">
			<div class="toc-heading">Table of Contents</div>
			<div id="toc-padding"></div>
			<br />
			<br />
			<br />
		</div>
		<div id="book">
			<div class="chapter">
				<h2 id="introduction">Introduction</h2>
<p>Welcome to our Terraform Workshop! </p>
<p>We&#39;ve been using Terraform to deploy Azure infrastructure for the past year, and have enjoyed the experience so much, we felt we needed to bring it to you. </p>
<h3 id="what-is-terraform-">What is Terraform?</h3>
<p><a href="https://www.terraform.io/">Terraform</a> is an open source tool Hashicorp that allows you to safely and predictably create, change, and improve infrastructure. It codifies APIs into declarative configuration files that can be shared amongst team members, treated as code, edited, reviewed, and versioned.</p>
<p>With Terraform you can:</p>
<ol>
<li>Write infrastructure as code</li>
<li>Plan changes to your infrastructure</li>
<li>Create reproducible infrastrcuture</li>
</ol>
<h4 id="write-infrastructure-as-code">Write infrastructure as code</h4>
<p>With Terraform, you define infrastructure as code to increase productivity and transparency. Your Terraform can be (and should be) stored in a version control system, shared, and collaborated on by a team. With this approach, you track the incremental changes and historical state of your infrastructure. And, by nature, the codification of the infrastructure is automation friendly, so it can sit inside of a CICD pipeline to dynamically deploy infrastructure, then the code that runs on the infrastructure.</p>
<h4 id="plan-changes-to-your-infrastructure">Plan changes to your infrastructure</h4>
<p>Terraform provides an elegant user experience for teams to safely and predictably make changes to infrastructure. </p>
<p>Teams can understand how a minor change could have potential cascading effects across an infrastructure before executing that change (through a Terraform process called a plan). Terraform builds a dependency graph from the configurations, and walks this graph to generate plans, refresh state, and more.</p>
<p>Terraform also separates the <em>plan</em> process discussed above from the <em>apply</em> process, which makes the changes to the infrastructure. Separating plans and applies reduces mistakes and uncertainty at scale. Plans show teams what would happen, applies execute changes.</p>
<p>Terraform also have a rich library of infrastructure <em>providers</em> (Azure, AWS, GCP, OpenStack, VMware, Hyper-V, and more), which allow you to make changes across multiple on-premises and cloud environments at the same time. </p>
<h4 id="create-reproducible-infrastrcuture">Create reproducible infrastrcuture</h4>
<p>Terraform lets teams easily use the same configurations in multiple places to reduce mistakes and save time. You can use the same configuration files to deploy multiple identical environments. Common Terraform configurations (like SQL/IIS or LEAN/MEAN stack apps) can be packaged as modules and used across teams and organizations.</p>
<h3 id="about-the-workshop">About the Workshop</h3>
<p>Our speakers include:</p>
<ul>
<li><p><a href="https://www.linkedin.com/in/eric-rhoads">Eric Rhoads</a></p>
<ul>
<li>Azure Cloud Solution Architect (CSA), <a href="http://kizan.com">KiZAN Technologies</a></li>
</ul>
</li>
<li><p><a href="https://twitter.com/mikebranstein">Mike Branstein</a></p>
<ul>
<li>Azure Cloud Solution Architect (CSA), <a href="http://kizan.com">KiZAN Technologies</a></li>
<li><a href="https://brosteins.com">Brosteins</a></li>
<li><a href="https://www.linkedin.com/in/mikebranstein/">LinkedIn</a></li>
</ul>
</li>
</ul>
<h3 id="getting-started">Getting Started</h3>
<p>To get started you&#39;ll need the following pre-requisites. Please take a few moments to ensure everything is installed and configured.</p>
<ul>
<li>Microsoft Windows PC or Mac or Linux. Just have a laptop.</li>
<li><a href="https://azure.microsoft.com">Azure Subscription</a> (Trial is ok, or an Azure account linked to a Visual Studio subscription. See later sections of this chapter to create a free trial account or activate your Visual Studio subscription)</li>
</ul>
<h3 id="what-you-re-building">What You&#39;re Building</h3>
<p>Using Terraform to deploy Azure infrastructure is easy, but there&#39;s a lot of different resources you could deploy - Azure is big. Really big. Too big to talk about all things Azure in a single day. </p>
<p>We&#39;ve assembled an exciting workshop to introduce you to several Azure services that infra and dev teams typically deploy:</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/azure/app-service/overview-hosting-plans">App Service Plan</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/app-service/web/">Web app</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/sql-database/">Azure SQL Database</a></li>
<li><a href="https://azure.microsoft.com/en-us/services/virtual-machines/">Virtual Machines</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/application-gateway/overview">App Gateway</a></li>
</ul>
<p>In this workshop, you&#39;ll learn be learning how to get started with Terraform and provision Azure resources. </p>
<p>In chapter 2, you&#39;ll start by writing code to deploy Azure resource groups, an App Service Plan, and an App Service. </p>
<p>Then in chapter 3, you&#39;ll learn how to create reusage code modules to create identical dev and prod environments. </p>
<p>Chapter 4 introduces you to Terraform state files, which is how Terraform manages the state of your infrastructure.</p>
<p>In chapter 5, you&#39;ll add a SQL database to your infrastructure and deploy a web site.</p>
<p>The workshop wraps up in chapter 6 by deploying an Azure App Gateway and Web Applicaiton Firewall (WAF) to protect the website you deployed previously.</p>
<h3 id="key-concepts-and-takeaways">Key concepts and takeaways</h3>
<ul>
<li>Navigating the Azure portal</li>
<li>Using Azure Resource Groups to manage multiple Azure services</li>
<li>Deploying a web app to Azure web app service using Terraform</li>
<li>Terraform naming conventions and standards </li>
<li>Why Terraform state files are important and methods for managing state</li>
<li>Deploying Azure SQL databases and apps from Visual Studio</li>
<li>How Azure App Gateways and WAFs work, and how to deploy with Terraform</li>
</ul>
<h3 id="materials">Materials</h3>
<p>You can find additional lab materials and presentation content at the locations below:</p>
<ul>
<li>Presentation: <a href="https://github.com/mikebranstein/terraform-workshop">https://github.com/mikebranstein/terraform-workshop</a></li>
<li>Source code for the code used in this guide: <a href="https://github.com/mikebranstein/terraform-workshop">https://github.com/mikebranstein/terraform-workshop</a></li>
<li>This guide: <a href="https://github.com/mikebranstein/terraform-workshop-instructions">https://github.com/mikebranstein/terraform-workshop-instructions</a></li>
</ul>
<h3 id="creating-a-trial-azure-subscription">Creating a Trial Azure Subscription</h3>
<blockquote>
<p><strong>If you already have an Azure account</strong> </p>
<p>If you have an Azure account already, you can skip this section. If you have a Visual Studio subscription (formerly known as an MSDN account), you get free Azure dollars every month. Check out the next section for activating these benefits.</p>
</blockquote>
<p>There are several ways to get an Azure subscription, such as the free trial subscription, the pay-as-you-go subscription, which has no minimums or commitments and you can cancel any time; Enterprise agreement subscriptions, or you can buy one from a Microsoft retailer. In exercise, you&#39;ll create a free trial subscription.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a Free Trial Subscription
</h4>

<p>Browse to the following page <a href="http://azure.microsoft.com/en-us/pricing/free-trial/">http://azure.microsoft.com/en-us/pricing/free-trial/</a> to obtain a free trial account.</p>
<p>Click <em>Start free</em>.</p>
<p>Enter the credentials for the Microsoft account that you want to use. You will be redirected to the Sign up page.</p>
<blockquote>
<p><strong>Note</strong> </p>
<p>Some of the following sections could be omitted in the Sign up process, if you recently verified your Microsoft account.</p>
</blockquote>
<p>If you already ahve an Azure subscription tied to your Microsoft account, you may see a screen like this:</p>
<p><img src="images/chapter0/existing-subscription.png" class="img-medium" /></p>
<p>You&#39;re wekcome you use your existing subscription for the bootcamp. If you&#39;re planningto use your existing subscription, you can skip this exercise. Click <em>Sign Up</em> to create a new subscription.</p>
<p>Complete step 1 by entering your mobile phone number.</p>
<p><img src="images/chapter0/verify.png" class="img-medium" /></p>
<p>Select <em>Text me</em> or <em>Call me</em> to verify that you are a real person. Typein the verification code you receive on the phone or via text.</p>
<p>Next, complete the Payment information section.</p>
<blockquote>
<p><strong>A Note about your Credit Card</strong> </p>
<p>Your credit card will not be billed, unless you remove the spending limits. If you run out of credit, your services will be shut down unless you choose to be billed.</p>
</blockquote>
<p><img src="images/chapter0/payment.png" class="img-medium" /></p>
<p>Press <em>Next</em> after completing the credit card section.</p>
<p>In the <em>Technical Support</em> section, select the last option (No technical support) and click <em>Next</em>.</p>
<p><img src="images/chapter0/tech-support.png" class="img-medium" /></p>
<p>In the <em>Agreement</em> section, check the <em>I agree to the subscription Agreement</em>, <em>offer details</em>, and <em>privacy statement</em> option, and click <em>Sign up</em>.</p>
<p>Your free subscription will be set up, and after a while, you can start using it. Notice that you will be informed when the subscription expires.</p>
<p><img src="images/chapter0/agreement.png" class="img-medium" /></p>
<p>Your free trial will expire in 29 days from it&#39;s creation.</p>
<div class="exercise-end"></div>

<h3 id="activating-visual-studio-subscription-benefits">Activating Visual Studio Subscription Benefits</h3>
<p>If you happen to be a Visual Studio subscriber (formerly known as MSDN) you can activate your Azure Visual Studio subscription benefits. It is no charge, you can use your MSDN software in the cloud, and most importantly you get up to $150 in Azure credits every month. You can also get 33% discount in Virtual Machines and much more.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Activate Visual Studio Subscription Benefits
</h4>

<p>To active the Visual Studio subscription benefits, browse to the following URL: <a href="http://azure.microsoft.com/en-us/pricing/member-offers/msdn-benefits-details/">http://azure.microsoft.com/en-us/pricing/member-offers/msdn-benefits-details/</a></p>
<p>Scroll down to see the full list of benefits you will get for being a MSDN member. There is even a FAQ section you can read.</p>
<p>Click <em>Activate your monthly Azure credit</em> to activate the benefits.</p>
<p><img src="images/chapter0/activate.png" class="img-medium" /></p>
<p>You will need to enter your Microsoft account credentials to verify the subscription and complete the activation steps.</p>
<div class="exercise-end"></div>

<h3 id="preparing-your-azure-environment">Preparing your Azure environment</h3>
<p>You might be wondering how you can participate in a cloud workshop and not need any software installed.</p>
<p>Thanks to the Azure Resource Manager and some nifty templates I put together, we&#39;re going to provision a virtual machine (VM) with Visual Studio (and all the tools you&#39;ll need) installed in your Azure subscription. From that point forward, you can work from the VM. </p>
<p>It takes about 15 minutes to get the VM deployed to your subscription, so let&#39;s get started!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Provisioning a Visual Studio Community VM in your Azure Subscription
</h4>

<p>First, we&#39;ll createa storage account and copy a Windows VM image into the storage account.</p>
<p>In the Azure portal, click the <em>Cloud Shell</em> link at the top:</p>
<p><img src="images/chapter0/cloud-shell.png" class="img-override" /></p>
<p>If you&#39;ve never opened a Cloud Shell, you may encounter a message like this:</p>
<p><img src="images/chapter0/cloud-shell-2.png" class="img-override" /></p>
<p>If you see that message, select your Azure subscription and click <em>Create Storage</em>. Wait until you see a Cloud Shell (Bash) appear:</p>
<p><img src="images/chapter0/cloud-shell-3.png" class="img-override" /></p>
<p>Using the Bash Cloud Shell, run various Azure CLI commands. </p>
<p>Create a resource group named workshop-vm-rg:</p>
<pre><code class="lang-bash">az group create --location eastus --name workshop-vm-rg
</code></pre>
<p>Create a storage account in the resource group. Be sure to replace <storage-account-name> with a random storage account name (It must be unique!). For example, I used <em>mysameb2019</em>:</p>
<pre><code class="lang-bash">az storage account create --name &lt;storage-account-name&gt; --resource-group workshop-vm-rg --location eastus
</code></pre>
<p>Create a container in your storage account to hold VHDs:</p>
<pre><code class="lang-bash">az storage container create --account-name &lt;storage-account-name&gt; --name vhds
</code></pre>
<p>Start copying the virtual machine image from my storage account to yours.</p>
<pre><code class="lang-bash">az storage blob copy start --account-name &lt;storage-account-name&gt; --destination-blob terraform-win10-vs2019-v2.vhd --destination-container vhds --source-uri https://workshopvhds.blob.core.windows.net/vhds/terraform-win10-vs2019-v2.vhd
</code></pre>
<p>This will begin the copying process, but the copy may take 5-10 mintues. Use this command to check the status of the copy:</p>
<pre><code class="lang-bash">az storage blob show --account-name &lt;storage-account-name&gt; --name terraform-win10-vs2019-v2.vhd --container-name vhds --query &quot;properties.copy&quot;
</code></pre>
<p>When you run this command, you&#39;ll see various status messages showing you the copy progress. Wait for the completionTime and progress status to show a completion. In the image below, you can see my copy has not yet completed, and the progress is 141942784/136365212160, or ~0.1%.</p>
<p><img src="images/chapter0/status-2.png" class="img-override" /></p>
<p>Now that the copy has finished, get the URI of your virtual machine disk image. For example, it&#39;s <a href="https://storage-account-name}.blob.core.windows.net/vhds/terraform-win10-vs2019-v2.vhd">https://storage-account-name}.blob.core.windows.net/vhds/terraform-win10-vs2019-v2.vhd</a>. Keep this URI handy.</p>
<h4 id="deploying-the-virtual-machine">Deploying the Virtual Machine</h4>
<p>Start by clicking the <em>Deploy to Azure</em> button below.</p>
<p><a href="https://portal.azure.com/#create/Microsoft.Template/uri/https%3A%2F%2Fraw.githubusercontent.com%2Fmikebranstein%2Fvscommunity-workshop-vm%2Fmaster%2Ftemplate.json" target="_blank"><img src="http://azuredeploy.net/deploybutton.png" class="img-override" /></a></p>
<p>This opens the Azure portal in a new tab of your browser. If you&#39;re prompted to sign in, do so. </p>
<p>When the page loads, you&#39;ll see this custom deployment page:</p>
<p><img src="images/chapter0/custom-deployment.png" class="img-override" /></p>
<h4 id="under-basics-select-enter-the-following">Under <em>Basics</em>, select/enter the following</h4>
<ul>
<li>Subscription: <em>your Azure subscription</em></li>
<li>Resource group: <em>Create new</em></li>
<li>Resource group name: <em>workshop-vm-rg</em>, (the name of the RG you created previously)</li>
<li>Location: <em>East US</em></li>
<li>Os Blob Uri: <em>the URI of the virtual machine image you just finished copying</em></li>
</ul>
<blockquote>
<p><strong>Resource Groups</strong> </p>
<p>Formally, resource groups provide a way to monitor, control access, provision and manage billing for collections of assets that are required to run an application, or used by a client or company department. Informally, think of resource groups like a file system folder, but instead of holding files and other folders, resource groups hold azure objects like storage accounts, web apps, functions, etc.</p>
</blockquote>
<blockquote>
<p><strong>Naming Resource Groups</strong> </p>
<p>I like to name my resource groups after their purpose, and append them with <em>-rg</em>, which signifies they are a resource group. </p>
</blockquote>
<h4 id="under-settings-enter">Under <em>Settings</em>, enter</h4>
<ul>
<li>Virtual Machine Name: <em>workshop-vm</em>, or some other name that is less than 15 characters long, and no special characters</li>
<li>Admin Username: <em>your first name</em>, or some other username without spaces</li>
<li>Admin Password: <em>P@ssW0rd1234</em>, or another 12-character password with upper, lower, numbers, and a special character </li>
<li>Os Blob URI: <em>https://{storage-account-name}.blob.core.windows.net/vhds/terraform-win10-vs2019-v2.vhd</em></li>
</ul>
<blockquote>
<p><strong>WARNING</strong> </p>
<p>Do not forget your username and password. Write it down for today. </p>
</blockquote>
<h4 id="approving-the-purchase">Approving the &quot;Purchase&quot;</h4>
<p>Scroll down to the bottom of the page and click <em>I agree to the terms and conditions stated above</em>.</p>
<p>Press the <em>Purchase</em> button.</p>
<h4 id="deploying-the-vm">Deploying the VM</h4>
<p>After a few moments, the deployment of your VM will begin, and you&#39;ll see a status notification in the upper right:</p>
<p><img src="images/chapter0/deployment-start1.png" class="img-override" /></p>
<p>...and a deployment tile on your dashboard:</p>
<p><img src="images/chapter0/deployment-start2.png" class="img-override" /></p>
<p>Now, wait for about 10 minutes and your virtual machine will be deployed and ready to use.</p>
<div class="exercise-end"></div>

<p>That&#39;s it for the pre-requisites for today&#39;s workshop. Wait until your VM is created, and we&#39;ll be getting started soon!</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="getting-started-in-azure">Getting started in Azure</h2>
<h3 id="pre-requisites">Pre-requisites</h3>
<p>Before we go any further, be sure you have all the pre-requisites downloaded and installed. You&#39;ll need the following:</p>
<ul>
<li>Microsoft Windows PC or Mac</li>
<li>Evergreen web browser (Edge, Chrome, Firefox)</li>
<li><a href="https://azure.microsoft.com">Azure Subscription</a> (trial is ok, and you should have already done this in the chapter 0)</li>
<li>A Visual Studio Community edition VM running in Azure (see chapter 0 for setting this up)</li>
</ul>
<blockquote>
<p><strong>NOTE</strong></p>
<p>If you&#39;ve been following along, you should have all of these above items. </p>
</blockquote>
<h3 id="organizing-your-resources-in-the-azure-portal">Organizing your resources in the Azure portal</h3>
<p>One of the most important aspects of your Azure subscription and using the Azure portal is organization. You can create a lot of Azure resources very quickly in the portal, and it can become cluttered quickly. So, it&#39;s important to start your Azure subscription off right.</p>
<p>Our first stop will be to create a new Dashboard to organize our Azure resources we&#39;re building today.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a Dashboard
</h4>

<h4 id="creating-a-dashboard">Creating a Dashboard</h4>
<p>We&#39;ll start by creating a dashboard. </p>
<p>Login to the Azure portal, click <em>+</em>, give the dashboard name, and click <em>Done customizing</em>.</p>
<p><img src="images/chapter1/new-dashboard.gif" class="img-medium" /></p>
<p>That was easy! Dashboards are a quick way of organizing your Azure services. We like to create one for the workshop because it helps keep everything organized. You&#39;ll have a single place to go to find everything you build today.</p>
<h4 id="pinning-a-resource-group-to-the-dashboard">Pinning a Resource Group to the Dashboard</h4>
<p>Now that you have a new dashboard, let&#39;s put something on it. We&#39;ll be searching for the resource group you created in chapter 0 (the one that is holding your VM), and pinning it to this dashboard.</p>
<blockquote>
<p><strong>Resource Groups</strong> </p>
<p>You&#39;ll recall from the last chapter that resource groups provide a way to monitor, control access, provision and manage billing for collections of assets that are required to run an application, or used by a client or company department. Informally, think of resource groups like a file system folder, but instead of holding files and other folders, resource groups hold azure objects like storage accounts, web apps, functions, etc.</p>
</blockquote>
<p>Start by searching for the resource group you created in chapter 0. My resource group was called <em>workshop-rg</em>. </p>
<p><img src="images/chapter1/find-resource-group.gif" class="img-override" /></p>
<p>Click in the search bar at the top. If you&#39;re lucky your resource group will be at the very top (like mine was). If not, type it&#39;s name and click on it.</p>
<p>This opens the resource group. Next, click the <em>pin</em> icon at the upper-right to pin the resource group to your dashboard:</p>
<p><img src="images/chapter1/pin-resource-group.png" class="img-large" /></p>
<p>Finally, close the resource group, by clicking the <em>X</em> in the upper right corner (next to the <em>pin</em> icon). You should see the resource group pinned to your dashboard:</p>
<p><img src="images/chapter1/pinned.png" class="img-medium" /></p>
<p>Now that you have the VM&#39;s resource group pinned to your dashboard, it will be easy to locate the VM in later exercises.</p>
<p>Go ahead and click on the Virtual machine, then pin it to the dashboard. When you&#39;re finished, you should see something like this:</p>
<p><img src="images/chapter1/vm-pin.gif" class="img-medium" /></p>
<div class="exercise-end"></div>

<p>That wraps up the basics of creating dashboard, creating resource groups, and pinning resources to a dashboard. We&#39;re not going to take a deep dive into Azure Resource Group. If you&#39;re interested in learning more, check out this <a href="https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-group-portal">article</a>.</p>
<h3 id="configuring-your-virtual-machine-s-security-permissions">Configuring your virtual machine&#39;s security permissions</h3>
<p>Before we can deploy our Terraform code, we need to do some housekeeping and give your virtual machine the permissions to access your Azure environment.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Adding a Managed Service Identity to your Virtual Machine
</h4>


<p>Navigating to your Azure portal dashboard and locate the VM resource group you pinned earlier in this chapter and click on your virtual machine:</p>
<p><img src="images/chapter1/click-vm.png" class="img-override" /></p>
<p>Find the <em>Identity</em> blade on the left and set the <em>Status</em> to <em>On</em>. Press <em>Save</em>.</p>
<p><img src="images/chapter1/identity.png" class="img-override" /></p>
<p>This creates a security account (or Azure service principal, &quot;aka a service account&quot;) for your virtual machine. </p>
<p>Next, give the virtual machine <em>Contributor</em> rights to your Azure subscription. Follow this quick video to see how you can do that:</p>
<p><img src="images/chapter1/identity-2.gif" class="img-override" /></p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>


<h3 id="logging-into-your-virtual-machine">Logging into your virtual machine</h3>
<p>Next, let&#39;s get logged into the VM that we created in chapter 0. </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Logging into your VM
</h4>

<p>Start by navigating to your Azure portal dashboard. </p>
<p>Locate the VM resource group you pinned earlier in this chapter and click on your virtual machine:</p>
<p><img src="images/chapter1/click-vm.png" class="img-override" /></p>
<p>Click the <em>Connect</em> button.</p>
<p><img src="images/chapter1/connect.png"/></p>
<p>This displays a download window on the right. Press the <em>Download RDP file</em> button.</p>
<p><img src="images/chapter1/connect-download.png" /></p>
<p>This downloads a file to your computer that will open in your Remote Desktop program.</p>
<p><img src="images/chapter1/connect-download-2.png" /></p>
<p>Click the downloaded file to open a connection to your VM. Enter your username and password you created earlier. </p>
<p><img src="images/chapter1/connect-password.png" class="img-override" /></p>
<p>Click <em>OK</em> to connect.</p>
<p>If you&#39;re prompted by a security message, respond <em>Yes</em>:</p>
<p><img src="images/chapter1/connect-security.png" class="img-override" /></p>
<p>You&#39;re now connected to your VM. </p>
<blockquote>
<p><strong>Download additional software</strong></p>
<p>If you&#39;re like me, you have a standard toolset you like to use. Please, download software for your VM and don&#39;t forget your browser of choice, Notepad++, Visual Studio Code, etc.</p>
</blockquote>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<p>Now that you&#39;re connected to your VM, you can continue to workshop from inside the VM. </p>
<blockquote>
<p><strong>Running a VM in Azure</strong> </p>
<p>If you&#39;re worried about excessive charges to your Azure subscription because you&#39;re running a VM constantly, don&#39;t worry. This VM is programmed to shut itself down every evening at 7:00 PM EST. </p>
</blockquote>
<h3 id="clone-project-from-master-branch">Clone project from master branch</h3>
<p>Let&#39;s get started by getting the <code>master</code> branch.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Getting the workshop files
</h4>

<p>Clone or download the <code>master</code> branch from <a href="https://github.com/mikebranstein/terraform-workshop">https://github.com/mikebranstein/terraform-workshop</a>.</p>
<p>Use this <a href="https://github.com/mikebranstein/terraform-workshop/archive/master.zip">link</a> to download a zip file of the <code>master</code> branch.</p>
<p><img src="images/chapter1/downloaded-zip.png" class="img-small" /></p>
<blockquote>
<p><strong>Unblock the .zip file!</strong> </p>
<p>Don&#39;t open the zip file yet. You may need to unblock it first!</p>
</blockquote>
<p>If you&#39;re running Windows, right-click the zip file and go to the properties option. Check the <em>Unblock</em> option, press <em>Apply</em>, press <em>Ok</em>. Don&#39;t worry that the image below has a different file name - it&#39;s the same process.</p>
<p><img src="images/chapter1/unblock.gif" /></p>
<p>Now it&#39;s safe to unzip the file. </p>
<div class="exercise-end"></div>

<h3 id="about-contoso-university">About Contoso University</h3>
<p>The Contoso University web app is a small app that is used to manage the faculty, students, courses, and grades of Contoso University. It&#39;s not very advanced, but comes with pre-seeded data, and is ideal to demonstrate the concepts of this workshop. </p>
<p>You won&#39;t be using it until later in the workshop, but it&#39;s good to have it downloaded now.</p>
<p>This completes the chapter.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="getting-started-with-terraform">Getting Started with Terraform</h2>
<p>In this chapter, you&#39;ll deploy five services in Azure which will make up the base of your web application infrastructure: a Resource Group, an App Service Plan, and an App Service. In later chapters, you&#39;ll add to this by provisioning a SQL Azure Database (made up of an Azure SQL resource and an Azure SQL Database resource).</p>
<h3 id="terraform-providers">Terraform Providers</h3>
<p>In this seciton, youwe&#39;re going to start our Teraform code by creating our first code file and adding a provider.</p>
<blockquote>
<p><strong>What is a provider?</strong></p>
<p>Providers tell Terraform what API it is interacting with for resource deployment. There are a number of officially supported Providers, as well as community-driven providers. The AzureRM Provider is one of the officially supported providers for Azure and the one we will be using throughout this workshop.</p>
</blockquote>
<p>Let&#39;s jump right in.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Getting started
</h4>

<p>Before we get started, let&#39;s create a folder to work out of. On your VM, create a folder in the root fo the C drive named <code>terraform</code>. We&#39;ll be working from this folder throughout the workshop.</p>
<p>Next, open Visual Studio Code, open the <code>terraform</code> folder you created, then create a new file. We are going to name this file &quot;main.tf&quot;. This is one of the standard file names used in Terraform. We will talk about the others later in the workshop.</p>
<blockquote>
<p><strong>What is a main.tf file?</strong></p>
<p>The <em>main.tf</em> file is where we will delcare our instructions to Azure for what infrastructure we want to deploy and how we want to deploy the infrastructure. </p>
</blockquote>
<p>The first thing we need to do is tell Terraform to use the Azure RM Provider. </p>
<p>Copy and paste the below section to the top of your main.tf file:</p>
<pre><code>provider &quot;azurerm&quot; {
    tenant_id       = &quot;&quot;
    subscription_id = &quot;&quot;
    use_msi = true
}
</code></pre><p>Make sure to place your Azure Tenant and Subscription ID inside the quotes next to the appropriate parameter.</p>
<blockquote>
<p><strong>Where do I find my Tenant and Subscription IDs?</strong></p>
<p>If you&#39;re unfamiliar with Azure, you may be wondering where to find these values. Check out the quick video below on where to find these values.</p>
</blockquote>
<p><img src="images/chapter2/ids.gif" class="img-override" /></p>
<p>Note - your Tenant ID is the Azure Active Directory Directory ID.</p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<h3 id="declaring-resources">Declaring Resources</h3>
<p>Terraform is a declarative language, menaing it describes an intended goal (or end-state) of an environment, rather than the steps to reach the goal (or end-state).</p>
<p>This means that when your Terraform code is executed, Terraform will dynamically determine the steps it needs to take to bring your target environment in-line with your code. For example, assume your code declares a virtual machine. When run against an environment where the virtual machine does not exist, Terraform will create that virtual machine. If it&#39;s run against an environment where the virtual mahcine already exists, it will either update the virtual machine (so it&#39;s configured according to your definition) or do nothing (because the virtual machine needs no changes).</p>
<p>Declarative infra-as-code (IaC) languages can be powerful, but sometimes the results an be unexpected if you don&#39;t understand how/why they work. We&#39;re not going to get into the debate topic right now, but it wouldn&#39;t take you long to search for the different viewpoints online.</p>
<p>Enough talking - let&#39;s get declaring!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Declaring resources
</h4>

<p>Now that we have established the Provider, we can begin declaring resources. Resources are always declared in the same way. We start with what resource we want to deploy, the alias name for the resource, and the parameters required to deploy the resource.</p>
<p>For example:</p>
<pre><code>resource &quot;azurerm_resource_group&quot; &quot;my_resource_alias&quot; {
  # key-value parameter pairs go here
  key1 = value1
  key2 = value2
}
</code></pre><p>Let&#39;s start by declaring an Azure resource group. </p>
<blockquote>
<p><strong>Resource Groups</strong> </p>
<p>Formally, resource groups provide a way to monitor, control access, provision and manage billing for collections of assets that are required to run an application, or used by a client or company department. Informally, think of resource groups like a file system folder, but instead of holding files and other folders, resource groups hold azure objects like storage accounts, web apps, functions, etc.</p>
</blockquote>
<p>Copy and paste the below section to create a new resource group:</p>
<pre><code># Resource Group
resource &quot;azurerm_resource_group&quot; &quot;application_rg&quot; {
    name     = &quot;tf-az-app1-dev-rg&quot;
    location = &quot;East US&quot;
}
</code></pre><p>This resource only requires two parameters: a name and location. </p>
<blockquote>
<p><strong>Aren&#39;t there more parameters?</strong></p>
<p>If you&#39;re familiar with Azure, you may be thinking there are a bunch of other optional parameters you could provide for a resource group. You&#39;re right. There are additional parameters which are accepted by Terraform if we wanted to configure aspects like resource tags, etc. For this workshop you&#39;ll be filling in required parameters only. If you want to see the full list of parameters available for a resource, click on the highlighted resource name &quot;azurerm_resource_group&quot; in your VS Code main.tf file, or check out the options <a href="https://www.terraform.io/docs/providers/azurerm/r/resource_group.html">here</a>. </p>
</blockquote>
<blockquote>
<p><strong>What&#39;s in the Azure RM Provider?</strong></p>
<p>There are a ton of resources you can declare using the AzureRM resource provider - too many to review here. Take a look at the <a href="https://www.terraform.io/docs/providers/azurerm/index.html">online documentation</a> to see a comprehensive list. You&#39;ll also be able to see required and optional parameters for each resoruce type.</p>
</blockquote>
<h4 id="declaring-an-app-service-plan">Declaring an App Service Plan</h4>
<p>Next, we are going to add the App Service Plan. Add the following code below the resource group resource in main.tf:</p>
<pre><code>resource &quot;azurerm_app_service_plan&quot; &quot;standard_app_plan&quot; {
    name = &quot;tf-standard-plan&quot;
    location = &quot;${azurerm_resource_group.application_rg.location}&quot;
    resource_group_name = &quot;${azurerm_resource_group.application_rg.name}&quot;
    sku {
        tier = &quot;Basic&quot;
        size = &quot;B1&quot;
    }
}
</code></pre><p>When parameters of a resource have multiple/sub-parameters, they are encapsulated with {}. If you&#39;re familiar with JSON, this shouldn&#39;t look too strange. In this case, the App Service Plan has a multi-property parameter for the sku tier and sku size.</p>
<blockquote>
<p><strong>Whoa...dot-notation in Terraform?!</strong></p>
<p>You may have noticed the ${} syntax with resource names and dot-notation in the above syntax. If you&#39;re familiar with programming languages, this won&#39;t surprise you. Terraform allows you to reference other declared resources by wrapping them in ${}, and using dot-notation to drill into properties of that resource. This comes in handy when you&#39;re chaining resources together, or when one resource depends on another resource. </p>
</blockquote>
<p>Looking back at the App Service Plan you just created, notice the &quot;location&quot; and &quot;resource_group_name&quot; properties. We used the dot-notation to obtain their values. We can pull other properties from other declared resources using the syntax &quot;azurerm_&lt;resource_type&gt;.&lt;resource_alias&gt;.&quot;. In this case the resource type is &quot;resource_group&quot;, the resource alias is &quot;application_rg&quot; (We provided the resource alias in the previous code snippet next to the declaration of the resource type), and the property we care about for location is &quot;.location&quot; and for resource_group_name it&#39;s &quot;.name&quot;.</p>
<p>Now that we have declared the Plan our Application Service will use, let&#39;s create the Azure Web App. Use the following code and add it to your main.tf file:</p>
<pre><code># Random Integer for App Service
resource &quot;random_integer&quot; &quot;ri&quot; {
    min = 10000
    max = 99999
}

resource &quot;azurerm_app_service&quot; &quot;app1_app_service&quot; {
    name = &quot;tf-az-app1-dev-app${random_integer.ri.result}&quot;
    location = &quot;East US&quot;
    resource_group_name = &quot;${azurerm_resource_group.application_rg.name}&quot;
    app_service_plan_id = &quot;${azurerm_app_service_plan.standard_app_plan.id}&quot;
}
</code></pre><blockquote>
<p><strong>A few words on naming conventions</strong></p>
<p>The standard naming convention in Terraform is to keep everything lowercase and separate key words by dashes. In addition to Terraform&#39;s standards, we have established here a pattern for naming resources in Azure. This pattern is a common best practice for Azure and can vary for each organization based on naming needs. The pattern above is as follows: &quot;tf&quot; to declare the resource was created by Terraform, &quot;az&quot; to denote this is an Azure resource (this comes in handy when in a hybrid scenario), &quot;app1&quot; is the application name, &quot;dev&quot; is the environment, and &quot;app&quot; is the shorthand chosen for the resource type. </p>
</blockquote>
<blockquote>
<p><strong>WARNING: Watch out for platform limitations when naming resources</strong></p>
<p>In some cases, you cannot use dashes in names of Azure resources (ex. Storage Account) so an alternative is to keep everything lowercase and have no separation of key words with dashes if you want to keep names uniform across the board.</p>
<p>Some resources must also have globally unique names (like Storage Accounts...again), so you may need adjust names accordingly. </p>
</blockquote>
<p>You may have noticed the random integer code block above - that&#39;s present to ensure you have a unique app service.</p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<p>The keen eye may have noticed we declared the Terraform resources in a specific order. Was that necesary? No. </p>
<p>Terraform is smart, and when it runs against your declarative code, it reads the entire code file in, parses it, determines resource dependencies, and then creates/updates the infra in the order determined by it&#39;s dependency calculations. </p>
<p>In other words, we could have added these resource code snippets in ANY order in the file, and Terraform will figure out the right way to order resources for proper deployment.</p>
<h3 id="deploying-resources-with-terraform">Deploying resources with Terraform</h3>
<p>Now that we have the &quot;main.tf&quot; file ready to go, let&#39;s deploy the resources.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Deploying with Terraform
</h4>

<p>Within Visual Studio Code, open a Terminal. Click &quot;Terminal &gt; New Terminal&quot;, then hit Enter.</p>
<p>In the terminal, navigate to the C:\terraform folder, where you created the main.tf file. </p>
<pre><code>cd c:\terraform 
</code></pre><p>Initialize Terraform:</p>
<pre><code class="lang-bash">terraform init
</code></pre>
<blockquote>
<p><strong>What does initialization do?</strong></p>
<p>The terraform init command is used to initialize a working directory containing Terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control. It is safe to run this command multiple times.</p>
<p>Behind the scenes, terraform init downloads any needed providers (like the AzureRM provider) when run, and ensures your code can run.</p>
</blockquote>
<p>You can see the effects of running terraform init from within VS Code: a <code>.terraform</code> folder is created, containing the AzureRM provider for your operating system:</p>
<p><img src="images/chapter2/init.png" class="img-small" /></p>
<p>Next, let&#39;s see what our terraform will create. Run the Terraform plan command:</p>
<pre><code class="lang-bash">terraform plan
</code></pre>
<p>The terraform plan command is used to create an execution plan. Terraform performs a refresh, unless explicitly disabled, and then determines what actions are necessary to achieve the desired state specified in the configuration files.</p>
<p>This command is a convenient way to check whether the execution plan for a set of changes matches your expectations without making any changes to real resources or to the state. For example, terraform plan might be run before committing a change to version control, to create confidence that it will behave as expected. You may also use terraform plan and save the output as part of an apporval process before making the changes permanent.</p>
<p>Finally, use Terraform to make the changes to your environment. Run terraform apply. When prompted, type &#39;yes&#39; to confirm you want to deploy the resources.</p>
<pre><code class="lang-bash">terraform apply
</code></pre>
<p>The resources will deploy to your Azure subscription exactly as written. </p>
<p><img src="images/chapter2/apply.png" class="img-override" /></p>
<h4 id="checking-your-deployment">Checking your deployment</h4>
<p>Open the Azure Portal (<a href="https://portal.azure.com">https://portal.azure.com</a>) and look for the resource group you created. Find the app service you deployed and click into the resource. On the main overview page you can findthe default URL of the application service. Click on this link. </p>
<p>You now have a base web application infrastructure where code can be deployed. Congrats! </p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<p>In the next chapter, we&#39;ll talk about how we can reformat this basic configuration file to be re-usable.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="developing-reusable-code">Developing Reusable Code</h2>
<p>In this chapter you&#39;ll learn:</p>
<ul>
<li>What a Terraform module is</li>
<li>How to generalize Terraform code to make it reusable</li>
<li>Use variables to pass data into modules</li>
</ul>
<h3 id="terraform-modules">Terraform Modules</h3>
<p>In the last chapter, you wrote your first Terraform code, and learned three Terraform commands: init, plan, and apply. As your Terraform code becomes more complex, and you do more deployments, you may find the need to reuse Terraform code. You can do this with modules.</p>
<blockquote>
<p><strong>So what is a module in Terraform anyways?</strong> </p>
<p>In the simplest terms, a module is a collection of declarative Terraform files, grouped together in a folder. That&#39;s right - Terraform sees any folder with Terraform files as a module. If you&#39;re familiar with other programming lanaguages, you can think of a module like an API - you pass data (variables) into it, infrastructure is provisioned, and data (output) is returned. </p>
</blockquote>
<p>You&#39;ll recall from the last chapter, that Terraform collects all &quot;.tf&quot; files in a folder (or rather, a module) when it runs. The files are combined into a single master code declaration, dependencies discovered, and infrastructure is provisioned in the order determined.</p>
<h4 id="structuring-modules">Structuring modules</h4>
<p>Modules consist of three files, generally:</p>
<ol>
<li>A <code>main.tf</code> file where all primary code exists. </li>
<li>A <code>variables.tf</code> or <code>vars.tf</code> file where variables for that module are declared. </li>
<li>An <code>output.tf</code> file where any module outputs are declared. </li>
</ol>
<p>You&#39;ve already seen what goes into a main.tf file so let&#39;s talk about the other two.</p>
<p>The variables file, is made up of all pre-defined variables (or module inputs) for a file. Here is an example of how to construct a variable:</p>
<pre><code>variable &quot;location&quot; {
    description = &quot;Location where Resources will be deployed&quot;
    default = &quot;East US&quot;
}
</code></pre><p>The example above declares a <em>location</em> variable, which can include a description and a default value, though these are not required. If no default value is supplied, the module will expect these to be supplied by some other means, either through direct user input or by outputs.</p>
<p>Speaking of outputs, let&#39;s look at an example of what might go into an <code>output.tf</code> file:</p>
<pre><code>output &quot;app_service_fqdn&quot; {
    value = &quot;${azurerm_app_service.app1_app_service.default_site_hostname}&quot;
}
</code></pre><p>The example above declares an &quot;app_service_fqdn&quot; output and specifies the value comes from the result of the app service default site hostname. This means we can use computed values from our deployment elsewhere. Like for example, in another module.</p>
<p>The ability for setting up inputs and outputs using declarative language gives us the flexibility needed to generalize configurations so they can be <em>stamped-out</em> on demand. </p>
<h3 id="creating-a-generalized-module">Creating a Generalized Module</h3>
<p>Now that you know what goes into a module, let&#39;s build one together.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Generalizing modules
</h4>

<p>Before we begin, clean up your <code>c:\terraform</code> fodler by removing the following files/folders:</p>
<ul>
<li>.terraform folder (use VS Code to delete it)</li>
<li>terraform.tfstate file</li>
<li>terraform.tfstate.backup file</li>
</ul>
<p>Create a new folder in your <code>C:\terraform</code> folder. We are going to call this folder <code>_modules</code>. </p>
<p>Next, create a sub-folder in <code>_modules</code> called <code>standard_application</code>. </p>
<p>Now move the <code>main.tf</code> file we created in the previous chapter into this folder. In VS Code, drag the file from it&#39;s current parent location to the <code>standard_application</code> sub-folder you just created.</p>
<p>Next, create two more files in the <code>standard_application</code> folder. Create an empty <code>variables.tf</code> file and an empty <code>output.tf</code> file. We&#39;ll populate these later as we get a better feel for what variables we need.</p>
<p>This creates the baseline of our module, but we aren&#39;t done. </p>
<p>We are going to create two more folders at the root of <code>C:\terraform</code>. First create a folder called <code>dev</code>, then a folder called <code>prod</code>. We&#39;ll work with these folders more toward the end of this section.</p>
<h4 id="generalizing-the-module">Generalizing the Module</h4>
<p>Technically the <code>main.tf</code> file we created earlier is part of a module now called <em>standard_application</em> but we cannot re-use it yet. There are certain parameters we have hard-coded which will prevent us from dynamically calling the module. Let&#39;s change that by replacing those hard-coded values with variables.</p>
<blockquote>
<p><strong>Before we go further</strong></p>
<p>Please remove the provider block at the top of the <code>main.tf</code> file we created earlier. Save the provider code -- we&#39;ll need it later. We&#39;ll talk about why you have to do this later. </p>
</blockquote>
<p>Open up the &quot;variables.tf&quot; file and paste the following code:</p>
<pre><code>variable &quot;location&quot; {
    description = &quot;Location where Resources will be deployed&quot;
}

variable &quot;application_plan_tier&quot; {
    description = &quot;Tier of the Application Plan (Free, Shared, Basic, Standard, Premium, Isolated)&quot;
}

variable &quot;application_plan_size&quot; {
    description = &quot;Instance Size of the Application Plan (F1, D1, B1, B2, B3, S1, S2, S3, P1v2, P2v2, P3v2, PC2, PC3, PC4, I1, I2, I3)&quot;
}

variable &quot;application_name&quot; {
    description = &quot;Name of the Application&quot;
}

variable &quot;environment&quot; {
    description = &quot;Environment of all deployed resources&quot;
}
</code></pre><blockquote>
<p><strong>More on variables</strong></p>
<p>We like to think of modules like an API. The variables represent input values that allow the module to be flexible and provision different infrastructure configurations - they form the API&#39;s surface and interface. The module&#39;s <code>main.tf</code> code then represents the implementation of the API. </p>
</blockquote>
<p>With our freshly declared variables, let&#39;s open up the &quot;output.tf&quot; file and paste the following:</p>
<pre><code>output &quot;app_service_fqdn&quot; {
    value = &quot;${azurerm_app_service.app1_app_service.default_site_hostname}&quot;
}
</code></pre><p>We will be using this output in a future chapter, and will discuss this in more detail at that time.</p>
<p>Let&#39;s move on to the <code>main.tf</code> file and begin generalizing the resources we previously created.</p>
<p>Replace the existing Resource Group block with the following code:</p>
<pre><code># Resource Group
resource &quot;azurerm_resource_group&quot; &quot;application_rg&quot; {
    name     = &quot;tf-az-${var.application_name}-${var.environment}-rg&quot;
    location = &quot;${var.location}&quot;
}
</code></pre><p>Variables are called by supplying ${var.<variable name>}. You&#39;ll also notice that you can place variables side-by-side in Terraform code (like we did with the <em>name</em> key/value pair above).</p>
<p>Next, let&#39;s generalize the App Service Plan and App Service:</p>
<pre><code># App Service Plan
resource &quot;azurerm_app_service_plan&quot; &quot;standard_app_plan&quot; {
    name                = &quot;tf-az-standard-${var.environment}-plan&quot;
    location            = &quot;${var.location}&quot;
    resource_group_name = &quot;${azurerm_resource_group.application_rg.name}&quot;
    sku {
        tier = &quot;${var.application_plan_tier}&quot;
        size = &quot;${var.application_plan_size}&quot;
    }
}

# Random Integer for Unique Names
resource &quot;random_integer&quot; &quot;ri&quot; {
    min = 10000
    max = 99999
}

# App Service
resource &quot;azurerm_app_service&quot; &quot;app1_app_service&quot; {
    name                = &quot;tf-az-${var.application_name}-${var.environment}-app${random_integer.ri.result}&quot;
    location            = &quot;${var.location}&quot;
    resource_group_name = &quot;${azurerm_resource_group.application_rg.name}&quot;
    app_service_plan_id = &quot;${azurerm_app_service_plan.standard_app_plan.id}&quot;
}
</code></pre><p>This concludes the exercise.</p>
<div class="exercise-end"></div>


<h3 id="calling-modules">Calling Modules</h3>
<p>In the last section, you learned how to take existing Terraform code and turn it into a generalized module. Now that we have this module, let&#39;s use it!</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Calling a module
</h4>

<p>In the last section, you created a <code>dev</code> and <code>prod</code> folder within <code>C:\terraform</code>. In this exercise, you&#39;ll be creating Terraform code in each folder and referencing the <em>standard_application</em> module.</p>
<p>Let&#39;s get started. </p>
<p>In the &quot;dev&quot; folder, create a new <code>main.tf</code> file. </p>
<blockquote>
<p><strong>Don&#39;t forget the provider!</strong></p>
<p>Remember when we got rid of the provider declaration in the <code>standard_application\main.tf</code> file earlier in this chapter? We are going to declare the provider in this file <code>dev\main.tf</code>. If a provider is not declared in a module, the module will use the provider of the configuration file that called the module. </p>
<p>It is generally best to keep provider declarations at the root folder where modules will be called. Only declare a provider in a module when you need to override the default provider used (like when you need to use a specific provider version for compatibility).</p>
</blockquote>
<p>Open the <code>dev\main.tf</code> file you just created and paste the following code (or the provider code you saved earlier):</p>
<pre><code>provider &quot;azurerm&quot; {
    tenant_id       = &quot;&quot;
    subscription_id = &quot;&quot;
    use_msi = true
}
</code></pre><p>Just like before, make sure to place your Azure Tenant and Subscription ID inside the quotes next to the appropriate parameter.</p>
<p>Next we are going to call the previously created &quot;standard_application&quot; module and supply the required values. </p>
<blockquote>
<p><strong>Module inception?</strong></p>
<p>If you recall, modules are simply a folder with Terraform code within. So technically, the new <code>main.tf</code> file you created <em>is</em> a module...and we&#39;ll be adding code to call the <em>standard_application</em> module. In other words, modules can call other modules. </p>
<p>We&#39;re going to call the &quot;standard_application&quot; module to generate both a dev environment and a prod environment (hence the <code>dev</code> and <code>prod</code> folders). In large deployments, this saves us time. It also reduces the chance of errors because we know the same infrastructure will be deployed -- using the standards that we have set in the module (for naming convention, etc.).</p>
</blockquote>
<p>Paste the following code below the provider block:</p>
<pre><code>module &quot;standard_application&quot; {
    source                     = &quot;../_modules/standard_application/&quot;

    environment                = &quot;dev&quot;
    application_name           = &quot;app1&quot;
    location                   = &quot;East US&quot;
    application_plan_tier      = &quot;Basic&quot;
    application_plan_size      = &quot;B1&quot;
}
</code></pre><p>To call a module, declare it with a module {} block. The name of the module can be anything you want. In our case the name is &quot;standard_application&quot;. The source parameter specifies where the module is located in the file system, relative to the current file. The rest of the parameters are the variables we created earlier. Remember, any variable without a default value must be supplied by the user when calling the module directly.</p>
<p>It&#39;s good to know that modules don&#39;t have to be located on your local file system - they can be located in an external location. Tht&#39;s a more advanced topic, and we&#39;re not going to cover it in today&#39;s workshop. Feel free to investigate further if you&#39;re interested.</p>
<h4 id="testing-your-changes">Testing your changes</h4>
<p>Before we go any further, we need to destroy the resources we created earlier. We could use a built-in command from Terraform, <code>terraform destroy</code> (which destroys anything created by Terraform), or we can manually delete the resources from the Azure Portal by deleting the resource group we deployed previously.</p>
<p>It&#39;s probably easiest to navigate to the Azure portal and delete the resource group. Do that now. Come back here once you&#39;re finished. </p>
<p>Now that your Azure environment is cleaned up, let&#39;s deploy the resources like we did before.</p>
<p>First make sure we are in the c:\terraform\dev folder in our terminal. If not, cd to the appropriate folder level:</p>
<pre><code class="lang-bash">cd c:\terraform\dev
</code></pre>
<p>Run <code>terraform init</code> to initialize our configuration - you have to do this again because the new root <code>main.tf</code> file is located in a new sub-folder, <code>dev</code>.</p>
<pre><code class="lang-bash">terraform init
</code></pre>
<p>Next, run the <code>terraform plan</code> command. This isn&#39;t a required step for deployment but it is a good practice to follow in order to reduce potential errors.</p>
<pre><code class="lang-bash">terraform plan
</code></pre>
<p>If the output of the plan checks out, let&#39;s apply:</p>
<pre><code class="lang-bash">terraform apply
</code></pre>
<p>Type &#39;yes&#39; to confirm the deployment. The resources will deploy to your Azure subscription exactly as written. </p>
<h4 id="checking-your-deployment">Checking your deployment</h4>
<p>Open the Azure Portal and look for the resource group you created. This should look similar to what we deployed manually. Only now, we can deploy this as many times as we want with different values and it will return unique &quot;standard_application&quot; infrastructure deployments, each with their own unique resource group.</p>
<h4 id="extra-credit">Extra credit</h4>
<p>Just kidding. There&#39;s no extra credit, but if you want, copy the <code>dev\main.tf</code> file into the <code>prod</code> folder, change a couple of the parameter values we supplied, and deploy terraform from the prod folder to see a &quot;production&quot; environment next to your &quot;development&quot; environment. Note: This is not required for the other modules.</p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<p>Well done! Another chapter down and you&#39;ve learned how to make re-usable modules in Terraform. </p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="managing-terraform-state">Managing Terraform State</h2>
<p>In the last chapter, you had to delete Azure resources before redeploying with Terraform. Deleting resources is ok in a workshop, but it&#39;s not going to fly in production -- imagine that you had to delete your productioni database everytime you wanted to deploy Terraform. Ridiculous. Luckily, Terraform provides you with a way to manage this mischief.</p>
<p>In this chapter, you&#39;ll learn:</p>
<ul>
<li>the importance of Terraform state files</li>
<li>what a Terraform backend is</li>
<li>how to store and organize state files</li>
</ul>
<h3 id="terraform-state">Terraform State</h3>
<p>Up until now, you&#39;ve been using Terraform to deploy resources from the command line by running <em>terraform apply</em>. You may have noticed that a <em>terraform.tfstate</em> file was created and updated each time you ran Terraform. What&#39;s up with that file?</p>
<p>That file is called a Terraform state file, but what&#39;s it for?</p>
<p>Terraform must store state about your managed infrastructure and configuration. This state is used by Terraform to map real world resources to your configuration, keep track of metadata (like resource ids, names, etc.), and to improve performance for large infrastructures.</p>
<h4 id="why-state-files-important">Why state files important</h4>
<p>Imagine you&#39;re trying to create a virtual machine using Terraform, and the first time you run <em>terraform apply</em>, a VM is created and named <em>myVM</em>. Now, you update your Terraform code, adding another resource, then re-run <em>terraform apply</em>. Now, imagine that Terraform doesn&#39;t know anything about the environment it&#39;s deploying to. What should it do? Create a new VM named <em>myVM</em>?Update the existing VM? How does it know that VM already exists, and how does it know that VM is the same VM you referenced in your code?    </p>
<p>Terraform answers these questions by keeping a cached environment configuration within a file - the state file. When <em>terraform apply</em> is run, it examines the state file, and reads the environment configuration, then determines whether it will create, update, or delete resources. Even though Terraform can query the destination environment to see if resources exist, and create a plan from the <em>live</em> information, it&#39;s much faster to cache the environment state and work from it locally. </p>
<p>There are other benefits from managing state in a local file, but we&#39;re not goign to cover those in today&#39;s workshop. </p>
<h4 id="state-file-specifics-">State file specifics.</h4>
<p>Terraform state is stored (by default) in a local file named &quot;terraform.tfstate&quot;, but it can also be stored remotely, which works better in a team environment. In fact, when you integrate Terraform into a CICD pipeline, you need to store state files in a central location. </p>
<h3 id="storing-terraform-state-remotely">Storing Terraform state remotely</h3>
<p>Just like Terraform has providers for integrating with various platforms (Azure, AWS, VMWare, HyperV, etc.), it has providers to integrate with various <em>backends</em>.</p>
<blockquote>
<p><strong>What is a backend?</strong></p>
<p>A <em>backend</em> in Terraform determines how state is loaded and how an operation such as apply is executed. This abstraction enables non-local file state storage, remote execution, etc. For example, a backend could be a Windows or Linux file share, an Azure or AWS storage account, or a repository, like Artifactory or Azure DevOps. </p>
</blockquote>
<p>By default, Terraform uses the &quot;local&quot; backend, which is the normal behavior of Terraform you&#39;re used to (this is what created the terraform.tfstate files previously). </p>
<p>Here are some of the benefits of backends:</p>
<ol>
<li><p>Working in a team: Backends can store their state remotely and protect that state with locks to prevent corruption. Some backends such as Terraform Cloud even automatically store a history of all state revisions.</p>
</li>
<li><p>Keeping sensitive information off disk: State is retrieved from backends on demand and only stored in memory. If you&#39;re using a backend such as Azure storage accounts or Amazon S3, the only location the state ever is persisted is in the storage account or S3.</p>
</li>
<li><p>Remote operations: For larger infrastructures or certain changes, terraform apply can take a long, long time. Some backends support remote operations which enable the operation to execute remotely. You can then turn off your computer and your operation will still complete. Paired with remote state storage and locking above, this also helps in team environments.</p>
</li>
</ol>
<p>Backends are completely optional. You can successfully use Terraform without ever having to learn or use backends. However, they do solve pain points that afflict teams at a certain scale. If you&#39;re an individual, you can likely get away with never using backends.</p>
<blockquote>
<p><strong>Will we be using a backend in the workshop?</strong></p>
<p>Yes. In this workshop, you&#39;ll be using an Azure storage account as the backend. </p>
</blockquote>
<p>Ok, enough talking. Let&#39;s start doing.</p>
<h3 id="storing-state-remotely">Storing state remotely</h3>
<p>In this section, you&#39;ll be updating your Terraform code to configure a backend. But, before we can do that, we&#39;ll need to create an Azure storage account.</p>
<blockquote>
<p><strong>To Terraform or not to Terraform?</strong></p>
<p>This <em>IS</em> the question for backends. Now that you know of the importance of storing Terraform state files in a backend, should you use Terraform to create the backend store? To me, it doesn&#39;t matter. Typically, DevOps teams already have a preferred platform for data/artifact storage (like an Azure DevOps repository or Artifactory). In this case, your backend exists already. If you&#39;re just jumping into Terraform, it&#39;s ok to manually create your backend data store - just remember, it should be backed up!</p>
</blockquote>
<p>Let&#39;s create that storage account.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Create a Storage Account
</h4>

<p>Login to the Azure Portal, and open the Cloud Shell, like you did earlier in the workshop:</p>
<p><img src="images/chapter0/cloud-shell.png" class="img-override" /></p>
<p>Create a resource group named terraform-state-rg:</p>
<pre><code class="lang-bash">az group create --location eastus --name terraform-state-rg
</code></pre>
<p>Create a storage account in the resource group. Be sure to replace {storage-account-name} with a random storage account name (It must be unique!). For example, I used <em>tfstatemeb2019</em>:</p>
<pre><code class="lang-bash">az storage account create --name {storage-account-name} --resource-group terraform-state-rg --location eastus
</code></pre>
<p>Create a container in your storage account to hold your dev and prod statefiles:</p>
<p>For dev:</p>
<pre><code class="lang-bash">az storage container create --account-name {storage-account-name} --name dev
</code></pre>
<p>...and prod:</p>
<pre><code class="lang-bash">az storage container create --account-name {storage-account-name} --name prod
</code></pre>
<blockquote>
<p><strong>Organizing State Files</strong></p>
<p>As you store your state files, it&#39;s important to organize them so yhou don&#39;t accidentally overwrite or lose it. We&#39;re using a simple naming scheme of <em>dev</em> and <em>prod</em> to store ours, but you may need something more sophistocated in the real world.</p>
</blockquote>
<p>Now that your storage account is created, navigate to the storage account <em>Access control (IAM)</em> page in the Azure portal:</p>
<p><img src="images/chapter4/storage-iam.png" class="img-override" /></p>
<p>Click <em>Role Assignments</em>, then <em>Add</em> a Role Assignment to give your virtual machine access to read/write data to the storage account.</p>
<ul>
<li>Role: Storage Blob Data Contributor</li>
<li>Assign Access to: Virtual Machine</li>
<li>Subscription: your Azure subscription</li>
</ul>
<p>Then, select the VM name you&#39;re using for the workshop.</p>
<p>Click <em>Save</em>.</p>
<p><img src="images/chapter4/role-assignment.png" class="img-override" /></p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<p>Now that we have a storage account, let&#39;s update our Terraform code to use it.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Using a storage account as the backend
</h4>

<p>Before we get started, collect the following information:</p>
<ol>
<li><p>Storage account name: this is the name you gave to the account you created in the previous exercise. Mine was <em>tfstatemen2019</em> - yours will be different.</p>
</li>
<li><p>Subscription ID: The id of your Azure subscription (you should already have this saved in your main.tf file).</p>
</li>
<li><p>Tenant ID: The id of your Azure tenant (you should already have this saved in your main.tf file).</p>
</li>
</ol>
<h4 id="updating-the-dev-main-tf-file">Updating the dev main.tf file</h4>
<p>Open your main.tf for dev and add the following terraform code to the top of the file.</p>
<pre><code class="lang-json">terraform {
  backend &quot;azurerm&quot; {
    storage_account_name = &quot;storage-account-name&quot;
    resource_group_name  = &quot;storage-account-resource-group-name&quot;
    container_name       = &quot;dev&quot;
    key                  = &quot;terraform.tfstate&quot;
    use_msi              = true
    subscription_id  = &quot;00000000-0000-0000-0000-000000000000&quot;
    tenant_id        = &quot;00000000-0000-0000-0000-000000000000&quot;
  }
}
</code></pre>
<p>Update the code by chaning the values for <code>storage_account_name</code>, <code>resource_group_name</code>, <code>subscription_id</code>, and <code>tenant_id</code>.</p>
<h4 id="updating-the-prod-main-tf-file">Updating the prod main.tf file</h4>
<p>Open your main.tf for dev and add the following terraform code to the top of the file.</p>
<pre><code class="lang-json">terraform {
  backend &quot;azurerm&quot; {
    storage_account_name = &quot;storage-account-name&quot;
    resource_group_name  = &quot;storage-account-resource-group-name&quot;
    container_name       = &quot;prod&quot;
    key                  = &quot;terraform.tfstate&quot;
    use_msi              = true
    subscription_id  = &quot;00000000-0000-0000-0000-000000000000&quot;
    tenant_id        = &quot;00000000-0000-0000-0000-000000000000&quot;
  }
}
</code></pre>
<p>Update the code by chaning the values for <code>storage_account_name</code>, <code>resource_group_name</code>, <code>subscription_id</code>, and <code>tenant_id</code>.</p>
<h4 id="testing-your-changes">Testing your changes</h4>
<p>Navigate to the dev directory, where main.tf exists. Initialize Terraform.</p>
<pre><code class="lang-bash">terraform init
</code></pre>
<blockquote>
<p><strong>But I already initialized once</strong></p>
<p>Yes, that is true, but since you&#39;ve updated the backend configuration, you&#39;ll need to re-initialize Terraform to ensure it talks to your backend.</p>
</blockquote>
<p>Apply the changes:</p>
<pre><code class="lang-bash">terraform apply
</code></pre>
<p>Verify that Terraform ran successfully, then check the storage account to ensure a terrform.tfstate file exists in the <em>dev</em> blob container:</p>
<p><img src="images/chapter4/tfstate.png" class="img-small" /></p>
<blockquote>
<p><strong>Don&#39;t forget about prod!*</strong></p>
</blockquote>
<p>Before you continue, re-initialize prod and run <em>terraform apply</em>. Validate the terraform.tfstate file exists in the prod blob container before continuing.</p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<p>In this chapter, you learned why Terraform state files are important, and how to configure a Terraform backend to automatically store and retreive the state file. </p>
<p>This concludes the chapter.</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="adding-a-sql-server-and-deploying-your-app">Adding a SQL Server and Deploying your App</h2>
<p>In this chapter, you&#39;ll learn how to:</p>
<ul>
<li>provision a SQL server using Terraform</li>
<li>deploy a web application to the IaC environments</li>
</ul>
<h3 id="provisioning-a-sql-server">Provisioning a SQL Server</h3>
<p>Every great app needs a database, am i right? Myabe not, but we&#39;ll be provisioning an Azure SQL database regardless ;-)</p>
<blockquote>
<p><strong>What is Azure SQL Database?</strong></p>
<p>Azure SQL Database is a general-purpose relational database-as-a-service (DBaaS) based on the latest stable version of Microsoft SQL Server Database Engine. SQL Database is a high-performance, reliable, and secure cloud database that you can use to build data-driven applications and websites in the programming language of your choice, without needing to manage infrastructure.</p>
</blockquote>
<p>We&#39;ll be using Azure SQL Databases because they&#39;re easy to create, inexpensive, and the foundation of many apps in Azure. </p>
<p>Let&#39;s get to it.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Adding an Azure SQL Database to Terraform
</h4>

<p>Start by opening the <em>standard_application</em> module&#39;s main.tf file. Add the following to the bottom:</p>
<pre><code>resource &quot;azurerm_sql_server&quot; &quot;standard_sql_server&quot; {
  name                         = &quot;tf-az-standard-sql-${var.environment}-${random_integer.ri.result}&quot;
  resource_group_name          = &quot;${azurerm_resource_group.application_rg.name}&quot;
  location                     = &quot;${var.location}&quot;
  version                      = &quot;12.0&quot;
  administrator_login          = &quot;${var.sql_administrator_login}&quot;
  administrator_login_password = &quot;${var.sql_administrator_password}&quot;
}

resource &quot;azurerm_sql_database&quot; &quot;app1_db&quot; {
  name                = &quot;tf-az-${var.application_name}-${var.environment}-db&quot;
  resource_group_name = &quot;${azurerm_resource_group.application_rg.name}&quot;
  location            = &quot;${var.location}&quot;
  server_name         = &quot;${azurerm_sql_server.standard_sql_server.name}&quot;
}

resource &quot;azurerm_sql_firewall_rule&quot; &quot;test&quot; {
  name                = &quot;tf-az-${var.application_name}-${var.environment}-allow-azure-sqlfw${random_integer.ri.result}&quot;
  resource_group_name = &quot;${azurerm_resource_group.application_rg.name}&quot;
  server_name         = &quot;${azurerm_sql_server.standard_sql_server.name}&quot;
  start_ip_address    = &quot;0.0.0.0&quot; # tells Azure to allow Azure services
  end_ip_address      = &quot;0.0.0.0&quot; # tells Azure to allow Azure serivces
}
</code></pre><p>The first declaration creates an Azure SQL Server named <code>tf-az-standard-sql-{env}-{random-integer}</code> (you&#39;ll notice we re-used the same rnadom integer value to ensure the SQL Server name was unique). The second adds a database named <code>tf-az-${var.application_name}--${var.environment}-db</code> to the SQL Server. The third enables other Azure services to communicate with the SQL Server. </p>
<p>Notice we left the start_ip_address and end_ip_address as hard-coded values. We want to keep these inputs static so we did not generalize them. This will also not affect the dynamic creation of said rule, as it should be the same every time it gets created by Terraform.</p>
<h4 id="update-the-module-variables">Update the module variables</h4>
<p>You may have noticed we&#39;re using several new variables. Let&#39;s add them to the end of the <code>variables.tf</code> file:</p>
<pre><code>variable &quot;sql_administrator_login&quot; {
    description = &quot;Login for the Azure SQL Instance&quot;
}

variable &quot;sql_administrator_password&quot; {
    description = &quot;Password for the Azure SQL Instance&quot;
}
</code></pre><h4 id="supply-the-module-with-variable-values">Supply the module with variable values</h4>
<p>After adding the variables, update the supplied values of the variables in your main.tf files (dev and prod) with the supplied values.</p>
<p>For dev:</p>
<pre><code>module &quot;standard_application&quot; {
    source                     = &quot;../_modules/standard_application/&quot;

    environment                = &quot;dev&quot;
    application_name           = &quot;app1&quot;
    location                   = &quot;East US&quot;
    application_plan_tier      = &quot;Basic&quot;
    application_plan_size      = &quot;B1&quot;
    sql_administrator_login    = &quot;sqladmin&quot;
    sql_administrator_password = &quot;SQLP@ss123&quot;
}
</code></pre><p>...and prod:</p>
<pre><code>module &quot;standard_application&quot; {
    source                     = &quot;../_modules/standard_application/&quot;

    environment                = &quot;prod&quot;
    application_name           = &quot;app1&quot;
    location                   = &quot;East US&quot;
    application_plan_tier      = &quot;Basic&quot;
    application_plan_size      = &quot;B1&quot;
    sql_administrator_login    = &quot;sqladmin&quot;
    sql_administrator_password = &quot;SQLP@ss123&quot;
}
</code></pre><h4 id="testing-your-changes">Testing your changes</h4>
<p>Navigate to the dev folder, initialize Terraform:</p>
<pre><code class="lang-bash">terraform init
</code></pre>
<p>Run a plan to check out what&#39;s going to happen:</p>
<pre><code class="lang-bash">terraform plan
</code></pre>
<p>And apply the changes:</p>
<pre><code class="lang-bash">terraform apply
</code></pre>
<p>Go out to the Azure portal and check to see the resources have been created. </p>
<h4 id="getting-the-connection-string-to-your-database">Getting the connection string to your database</h4>
<p>Navigate to your dev SQL Database, and click on the <em>Connection strings</em> blade:</p>
<p><img src="images/chapter5/connection-strings.png" class="img-small" /></p>
<p>Copy the ADO.NET connection string and save it - you&#39;ll need this in the next step.</p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>


<h3 id="verify-the-web-app-works">Verify the web app works</h3>
<p>Before we deploy the web app, let&#39;s make sure it works. </p>
<p>You&#39;ll recall that we downloaded a .zip file to your Terraform VM in an earlier chapter. Locate the zip file, unzip it, open the directory, and let&#39;s go.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Compiling the solution
</h4>

<p>Start by opening the solution in <strong>Visual Studio 2019</strong> by double-clicking the <code>ContosoUniversity.sln</code> file in the <em>src</em> folder of the extracted files:</p>
<p><img src="images/chapter1/solution-file.png" /></p>
<blockquote>
<p><strong>Logging into Visual Studio the first time</strong></p>
<p>When you open Visual Studio the first time, it may take a few minutes. Be patient. You&#39;ll probably be prompted to sign in. Use your Microsoft account to sign in (the same one you used to sign up for the Azure trial).</p>
</blockquote>
<p>The opened solution should look like this:</p>
<p><img src="images/chapter1/opened-solution.png" /></p>
<p>Build and debug the solution. You should see the site load in your browser.</p>
<p><img src="images/chapter1/site.png" /></p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<p>That&#39;s it! You&#39;re up and running and ready to move on! In the next section, you&#39;ll learn how to deploy your website to Azure.</p>
<h3 id="understanding-app-service-and-web-apps">Understanding App Service and Web Apps</h3>
<p>In the last part of this chapter, you&#39;ll learn how to deploy a web app to an Azure Web App provisioned by Terraform. In short, I like to think of Azure Web Apps like IIS in the cloud, but without the pomp and circumstance of setting up and configuring IIS.</p>
<p>Web Apps are also part of a larger Azure service called the App Service, which is focused on helping you to build highly-scalable cloud apps focused on the web (via Web Apps), mobile (via Mobile Apps), APIs (via API Apps), and automated business processes (via Logic Apps). </p>
<p>We don&#39;t have time to fully explore all of the components of the Azure App Service, so if you&#39;re interested, you can read more <a href="https://azure.microsoft.com/en-us/services/app-service/">online</a>.</p>
<h4 id="what-is-an-azure-web-app-">What is an Azure Web App?</h4>
<p>As we&#39;ve mentioned, Web Apps are like IIS in the cloud, but calling it that seems a bit unfair because there&#39;s quite a bit more to  Web Apps:</p>
<ul>
<li><p><strong>Websites and Web Apps:</strong> Web Apps let developers rapidly build, deploy, and manage powerful websites and web apps. Build standards-based web apps and APIs using .NET, Node.js, PHP, Python, and Java. Deliver both web and mobile apps for employees or customers using a single back end. Securely deliver APIs that enable additional apps and devices.</p>
</li>
<li><p><strong>Familiar and fast:</strong> Use your existing skills to code in your favorite language and IDE to build APIs and apps faster than ever. Access a rich gallery of pre-built APIs that make connecting to cloud services like Office 365 and Salesforce.com easy. Use templates to automate common workflows and accelerate your development. Experience unparalleled developer productivity with continuous integration using Visual Studio Team Services, GitHub, and live-site debugging.</p>
</li>
<li><p><strong>Enterprise grade:</strong> App Service is designed for building and hosting secure mission-critical applications. Build Azure Active Directory-integrated business apps that connect securely to on-premises resources, and then host them on a secure cloud platform that&#39;s compliant with ISO information security standard, SOC2 accounting standards, and PCI security standards. Automatically back up and restore your apps, all while enjoying enterprise-level SLAs.</p>
</li>
<li><p><strong>Build on Linux or bring your own Linux container image:</strong> Azure App Service provides default containers for versions of Node.js and PHP that make it easy to quickly get up and running on the service. With our new container support, developers can create a customized container based on the defaults. For example, developers could create a container with specific builds of Node.js and PHP that differ from the default versions provided by the service. This enables developers to use new or experimental framework versions that are not available in the default containers.</p>
</li>
<li><p><strong>Global scale:</strong> App Service provides availability and automatic scale on a global datacenter infrastructure. Easily scale applications up or down on demand, and get high availability within and across different geographical regions. Replicating data and hosting services in multiple locations is quick and easy, making expansion into new regions and geographies as simple as a mouse click.</p>
</li>
<li><p><strong>Optimized for DevOps:</strong> Focus on rapidly improving your apps without ever worrying about infrastructure. Deploy app updates with built-in staging, roll-back, testing-in-production, and performance testing capabilities. Achieve high availability with geo-distributed deployments. Monitor all aspects of your apps in real-time and historically with detailed operational logs. Never worry about maintaining or patching your infrastructure again.</p>
</li>
</ul>
<h3 id="deploying-to-a-web-app-from-visual-studio">Deploying to a Web App from Visual Studio</h3>
<p>Now that you understand the basics of web apps, let&#39;s create one and deploy our app to the cloud! </p>
<h4 class="exercise-start">
    <b>Exercise</b>: Deploying to a Web App from Visual Studio 2019
</h4>

<p>In this exercise, let&#39;s start by deploying to the dev site. We won&#39;t actually deploy to the prod site, but that should be easy enough to do on your own once you&#39;ve done it in dev.</p>
<p>Before we deploy the web app, let&#39;s take a moment to update the database connection string with the proper settings.</p>
<p>Open the appsettings.json file and replace the <em>DefaultConnection</em> database connection string with the connection string to your SQL database. Remember, you saved this connection string earlier in the chapter.</p>
<blockquote>
<p><strong>WARNING</strong></p>
<p>You cannot just copy/paste the connection string. Inside the connection string is a username and password field that needs completed. The username and password is inside of your Terraform code - find it in <code>main.tf</code> and replace the values!</p>
</blockquote>
<p><img src="images/chapter5/appsettings.png" class="img-small" /></p>
<p>With the connection string updated, let&#39;s start the deployment process.</p>
<p>From Visual Studio, right-click the <em>ContosoUniversity</em> project and select <em>Publish</em>. In the web publish window, select <em>Microsoft Azure App Service</em>, <em>Select Existing</em>, and press <em>Publish</em>. </p>
<p>On the next page, select your Azure subscription, and select the Resource Group you created with Terraform earlier (mine was named <em>workshop-rg</em>), then select the dev web app created by your Terraform code. </p>
<p>Press <em>OK</em>.</p>
<p>After the web app is deployed, it will open the site. You should see the Contoso University site displayed.</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>

<blockquote>
<p><strong>Don&#39;t forget about Prod!</strong></p>
<p>Just in case you forgot, make sure you deploy the web app to prod before continuing.</p>
</blockquote>
<p>Bravo! You&#39;ve deployed a web app t the infrastructure you created via Terraform. This concludes the chapter, but the story isn&#39;t finished. In the next chapter, you&#39;ll learn how to secure your web apps by using an Azure App Gateway and Web Application Firewall (provisioned with Terraform, of course).</p>

			</div>
			<hr>
			<div class="chapter">
				<h2 id="securing-your-web-app-with-a-waf-app-gateway">Securing your Web App with a WAF/App Gateway</h2>
<p>In this chapter, we will be extending our existing web app infrastructure to include a layer of networking and security. We will be adding two new modules that integrate into what has been deployed already. This includes an Azure App Gateway resource.</p>
<blockquote>
<p><strong>What is a WAF/App Gateway?</strong></p>
<p>An Azure App Gateway is a managed Layer 7 Firewall service provided by Microsoft. This solution is sometimes referred to as a WAF or Web Application Firewall, and in fact, has a WAF mode which includes additional features such as protection against SQL Injections. The App Gateway is a powerful tool which gives us URL routing capabilities, and enterprise level network security and can integrate with other Azure services, including Azure Web Apps.</p>
</blockquote>
<h3 id="create-supporting-modules">Create Supporting Modules</h3>
<p>In addition to the App Gateway, we have some other network resources which will be deployed. This includes an Azure Virtual Network, Subnets, and a Public IP which will be used for the App Gateway. </p>
<blockquote>
<p><strong>Virtual Networks, Subnets, Public IPs</strong></p>
<p>The Virtual Network is a unique address space which contains one or more subnets and can be used for internal, isolated routing. Some PaaS services in Azure can be integrated with Virtual Networks, including App Services. Subnets are a way to carve up the address space and further isolate resources on the private network. Public IPs are resources in Azure which can be attached to services like the Application Gateway to provide a single entrypoint for web applications.</p>
</blockquote>
<h4 class="exercise-start">
    <b>Exercise</b>: Creating Core Services
</h4>

<p>Let&#39;s get on with creating our modules! </p>
<p>The first module we are going to create is for the Virtual Network and Subnets. This module will be called &quot;core_services&quot; and will be separated into it&#39;s own Resource Group.</p>
<blockquote>
<p><strong>Why a new Resource Group?</strong></p>
<p>We like to create networking resources in their own resource group to better control who has read/write access to them. Often times, we find customers have dedicated networking teams that manage networking resources.</p>
</blockquote>
<p>Start by creating a folder in <code>c:\terraform\_modules</code> called <code>core_services</code>. Next, create the three standard Terraform files: </p>
<ul>
<li>main.tf</li>
<li>variables.tf</li>
<li>output.tf</li>
</ul>
<p>Open the <code>core_services\variables.tf</code> file and paste the following code:</p>
<pre><code>variable &quot;functional_name&quot; {
    description = &quot;The primary purpose of the resources (ex. &#39;shared-services&#39;)&quot;
}

variable &quot;location&quot; {
    description = &quot;Location where Resources will be deployed&quot;
}

variable &quot;virtual_network_address_space&quot; {
    description = &quot;The Address Space of the Virtual Network&quot;
}

variable &quot;management_subnet&quot; {
    description = &quot;The Management Subnet (x.x.x.x/x)&quot;
}

variable &quot;gateway_subnet&quot; {
    description = &quot;The Gateway Subnet (x.x.x.x/x)&quot;
}

variable &quot;application_name&quot; {
    description = &quot;The Name of the Application&quot;
}

variable &quot;environment&quot; {
    description = &quot;Environment of all deployed resources&quot;
}
</code></pre><p>Nothing too new here, this just establishes the variables we plan to use for the module. Notice the <em>management_subnet</em> and <em>gateway_subnet</em> variables. This will allow users to pass in a CIDR address space (ex. 10.10.0.0/16) to define a subnet. There are ways to dynamically generate subnets using built-in Terraform functions, but we won&#39;t be diving into that in this workshop. Ask us about it if you&#39;re interested.</p>
<p>Next, let&#39;s populate our main.tf file with resources. Copy and paste the following code into your <code>core_services\main.tf</code> file:</p>
<pre><code># Resource Group
resource &quot;azurerm_resource_group&quot; &quot;network_rg&quot; {
    name     = &quot;tf-az-${var.functional_name}-${var.environment}-rg&quot;
    location = &quot;${var.location}&quot;
}

# Virtual Network
resource &quot;azurerm_virtual_network&quot; &quot;core_vnet&quot; {
    name                = &quot;tf-az-${var.functional_name}-${var.environment}-vnet&quot;
    location            = &quot;${var.location}&quot;
    resource_group_name = &quot;${azurerm_resource_group.network_rg.name}&quot;
    address_space       = [&quot;${var.virtual_network_address_space}&quot;]
}

# Subnets
resource &quot;azurerm_subnet&quot; &quot;management_subnet&quot; {
    name                 = &quot;tf-az-${var.functional_name}-mgmt-subnet&quot;
    address_prefix       = &quot;${var.management_subnet}&quot;
    virtual_network_name = &quot;${azurerm_virtual_network.core_vnet.name}&quot;
    resource_group_name  = &quot;${azurerm_resource_group.network_rg.name}&quot;
}

resource &quot;azurerm_subnet&quot; &quot;gateway_subnet&quot; {
    name                 = &quot;tf-az-${var.functional_name}-gw-subnet&quot;
    address_prefix       = &quot;${var.gateway_subnet}&quot;
    virtual_network_name = &quot;${azurerm_virtual_network.core_vnet.name}&quot;
    resource_group_name  = &quot;${azurerm_resource_group.network_rg.name}&quot;
}
</code></pre><p>We have created a new Resource Group, a Virtual Network, and two Subnets. Take note of the <em>address_space</em> parameter in the virtual network resource. The [] are required because the <em>address_space</em> parameter expects a list. Lists are declared with [] in Terraform. This means we could pass in more than one comma-separated address space if we wanted.</p>
<blockquote>
<p><strong>Why two subnets?</strong></p>
<p>When deploying network resources, we like to provision a management subnet and a subnet for the resource.  The management subnet is a standard subnet generally used for operations resources, like a VM to test configuration. The gateway subnet will be used for the App Gateway. This is purely a preference, but we&#39;ve found it helps ease management in emergencies, or during troubleshooting.</p>
</blockquote>
<p>We are almost done with this module. We need to add an output. Open the &quot;core_services\output.tf&quot; file and paste the following code:</p>
<pre><code>output &quot;gateway_subnet_id&quot; {
   value = &quot;${azurerm_subnet.gateway_subnet.id}&quot;
}
</code></pre><p>This output will be used to pass the gateway subnet id from this module to the next module we will create. We are doing this because the next module includes our Application Gateway, and one of the required parameters is the subnet id for gateway configuration.</p>
<h4 id="the-shared-services">The Shared Services</h4>
<p>The next module we will create is the shared services module. This is where our App Gateway resides, and is theoretically the place where all services which are shared between multiple applications should reside. Or rather, services which have a shared level of management between teams. Arguably we could have App Service Plans and SQL Server resources here since they could be shared between multiple applications but we prefer to keep these co-located with the applications they support, as they will generally be managed by the same teams.</p>
<p>Create a folder under <code>_modules</code> called <code>shared_services</code> and create the three Terraform files:</p>
<ul>
<li>main.tf</li>
<li>variables.tf</li>
<li>output.tf</li>
</ul>
<p>Open the <code>shared_services\variables.tf</code> file and paste the following code:</p>
<pre><code>variable &quot;functional_name&quot; {
    description = &quot;The primary purpose of the resources (ex. &#39;shared-services&#39;)&quot;
}

variable &quot;location&quot; {
    description = &quot;Location where Resources will be deployed&quot;
}

variable &quot;gateway_subnet_id&quot; {
    description = &quot;The Gateway Subnet (x.x.x.x/x)&quot;
}

variable &quot;application_name&quot; {
    description = &quot;The Name of the Application&quot;
}

variable &quot;environment&quot; {
    description = &quot;Environment of all deployed resources&quot;
}

variable &quot;app_service_fqdn&quot; {
    description = &quot;The FQDN of the Application Service&quot;
}
</code></pre><p>The <em>gateway_subnet_id</em> and the <em>app_service_fqdn</em> variables from above will be populated with the outputs from the <em>core_services</em> and <em>standard_application</em> modules. Way back in chapter three we created an output in our <em>standard_application</em> module called <em>app_service_fqdn</em> which retrieves the App Service FQDN for use with our Application Gateway. Likewise, the <em>gateway_subnet_id</em> will be passed from the output we created earlier in this chapter for use in the App Gateway resource. We&#39;ll talk more about how we pass in those outputs later.</p>
<p>Let&#39;s populate our <code>shared_services\main.tf</code> file with all the resources we need:</p>
<pre><code># Resource Group
resource &quot;azurerm_resource_group&quot; &quot;shared_rg&quot; {
    name     = &quot;tf-az-${var.functional_name}-${var.environment}-rg&quot;
    location = &quot;${var.location}&quot;
}

# Public IP Address
resource &quot;azurerm_public_ip&quot; &quot;gateway_pip&quot; {
    name                = &quot;tf-az-${var.functional_name}-${var.environment}-pip&quot;
    resource_group_name = &quot;${azurerm_resource_group.shared_rg.name}&quot;
    location            = &quot;${var.location}&quot;
    sku                 = &quot;Standard&quot;
    allocation_method   = &quot;Static&quot;
}

# App Gateway
resource &quot;azurerm_application_gateway&quot; &quot;gateway&quot; {
    name                = &quot;tf-az-${var.functional_name}-${var.environment}-ag&quot;
    location            = &quot;${var.location}&quot;
    resource_group_name = &quot;${azurerm_resource_group.shared_rg.name}&quot;

    sku {
        name        = &quot;WAF_v2&quot;
        tier        = &quot;WAF_v2&quot;
        capacity    = 1
    }

    gateway_ip_configuration {
        name        = &quot;tf-az-${var.functional_name}-ip-configuration&quot;
        subnet_id   = &quot;${var.gateway_subnet_id}&quot;
    }

    frontend_port {
        name = &quot;tf-az-${var.functional_name}-fep-80&quot;
        port = 80
    }

    frontend_ip_configuration {
        name                    = &quot;tf-az-${var.functional_name}-feip&quot;
        public_ip_address_id    = &quot;${azurerm_public_ip.gateway_pip.id}&quot;
    }

    backend_address_pool {
        name    = &quot;tf-az-${var.application_name}-beap&quot;
        fqdns   = [&quot;${var.app_service_fqdn}&quot;]
    }

    backend_http_settings {
        name                                = &quot;tf-az-${var.application_name}-http-80&quot;
        cookie_based_affinity               = &quot;Disabled&quot;
        path                                = &quot;/&quot;
        port                                = 80
        protocol                            = &quot;Http&quot;
        request_timeout                     = 20
        pick_host_name_from_backend_address = true 
    }

    http_listener {
        name                            = &quot;tf-az-${var.application_name}-listener&quot;
        frontend_ip_configuration_name  = &quot;tf-az-${var.functional_name}-feip&quot;
        frontend_port_name              = &quot;tf-az-${var.functional_name}-fep-80&quot;
        protocol                        = &quot;Http&quot;
    }

    request_routing_rule {
        name                        = &quot;tf-az-${var.application_name}-rule&quot;
        rule_type                   = &quot;Basic&quot;
        http_listener_name =        &quot;tf-az-${var.application_name}-listener&quot;
        backend_address_pool_name   = &quot;tf-az-${var.application_name}-beap&quot;
        backend_http_settings_name  = &quot;tf-az-${var.application_name}-http-80&quot;
    }
}
</code></pre><p>As you can see from the above code, the App Gateway is a fairly complicated resource. The first four sub-property blocks create the core components of the Application Gateway: <em>sku</em>, <em>gateway_ip_configuration</em>, <em>frontend_port</em>, <em>frontend_ip_configuration</em>. </p>
<p>The next four sub-property blocks are tied to specific application pools (in our case, the single web application): <em>backend_address_pool</em>, <em>backend_http_settings</em>, <em>http_listener</em>, <em>request_routing_rule</em>. </p>
<p>If we had multiple application back-ends (or apps) this App Gateway talked to, we would need to include those four sub-property blocks AGAIN for that application. This means the App Gateway resource can grow in a configuration file and is the primary reason we have split this resource out into its own module.</p>
<p>Notice the <em>gateway_ip_configuration</em> includes our <em>gateway_subnet_id</em> variable which will be populated with our output from the <em>core_services</em> module. The <em>backend_address_pool</em> includes our <em>app_service_fqdn</em> variable which will be populated with our output from the <em>standard_application</em> module.</p>
<p>We are not going to add any outputs in the <em>shared_services</em> module but we want the file to exist so that if we later decide we need information from this module we can update the module to include those outputs.</p>
<p>This concludes the exercise.</p>
<div class="exercise-end"></div>

<h3 id="putting-it-all-together">Putting it all together</h3>
<p>Now that we have created our modules, we need to tie them together in a single deployment. We will do this from the <code>dev\main.tf</code> file we created in a previous chapter.</p>
<h4 class="exercise-start">
    <b>Exercise</b>: Updating our root main.tf code
</h4>

<p>Open the <code>c:\terraform\dev\main.tf</code> file.</p>
<p>Below the backend <em>azurerm</em> {} code block paste the following code:</p>
<pre><code>module &quot;core_services&quot; {
    source                        = &quot;../_modules/core_services/&quot;

    environment                   = &quot;dev&quot;
    functional_name               = &quot;core-services&quot;
    location                      = &quot;East US&quot;
    virtual_network_address_space = &quot;10.10.0.0/16&quot;
    management_subnet             = &quot;10.10.1.0/24&quot; 
    gateway_subnet                = &quot;10.10.2.0/24&quot;
    application_name              = &quot;app1&quot;

}
</code></pre><p>This will create our core services. The Virtual Network will be created with a /16 address space and be carved up into two /24 subnets.</p>
<p>Next, we will add the following code after the module <em>standard_application</em> {} block:</p>
<pre><code>module &quot;shared_services&quot; {
    source            = &quot;../_modules/shared_services/&quot;

    environment       = &quot;dev&quot;
    functional_name   = &quot;shared-services&quot;
    location          = &quot;East US&quot;
    application_name  = &quot;app1&quot;
    gateway_subnet_id = &quot;${module.core_services.gateway_subnet_id}&quot;
    app_service_fqdn  = &quot;${module.standard_application.app_service_fqdn}&quot;
}  
</code></pre><blockquote>
<p><strong>A reminder on Ordering</strong></p>
<p>If you don&#39;t put these in the right order... that&#39;s okay! This is a declarative language. However, for ease of reading and logical ordering we are placing things in a specific order.</p>
</blockquote>
<p>Notice the <em>gateway_subnet_id</em> and the <em>app_service_fqdn</em> variables are retrieving values from the other modules. Terraform will wait for those modules to complete before attempting to start deployment of the shared_services module. Module outputs can be retrieved using ${module.<module name>.<output name>}. If no output is defined, the values cannot be retrieved directly from the module.</p>
<h4 id="deploying-to-dev-and-prod">Deploying to Dev and Prod</h4>
<p>With all the modules declared, we can now fully deploy our development environment. This time, we do not have to delete the previously created resources. This is because we have a state file from our previous module which will tell Terraform that one of the modules has already been deployed. Terraform will read the state file, verify the configurations match, then move on to deploying the new modules.</p>
<p>In our Terminal window, navigate to <code>c:\terraform\dev</code>, then paste the following command:</p>
<pre><code class="lang-bash">terraform plan
</code></pre>
<p>Once we have confirmed everything will deploy as expected, go ahead and run the apply:</p>
<pre><code class="lang-bash">terraform apply
</code></pre>
<p>Type &#39;yes&#39; to confirm the deployment. The resources will deploy to your Azure subscription exactly as written.</p>
<p>Next, let&#39;s copy our <code>dev\main.tf</code> file over to the prod folder. Once in the prod folder, go ahead and change the environment parameters values to <em>prod</em> (make sure to change this for each module called).</p>
<p>We can leave everything else the same. The ip addresses of the virtual network for production will overlap BUT the virtual networks are not connected with each other. So this will not cause any issues. In a real world scenario, the ip address spaces would likely be different even though they still probably wouldn&#39;t be connected to each other for the sake of resource isolation.</p>
<p>Now that you have the <code>prod\main.tf</code> file updated, open the terminal and cd to <code>c:\terraform\prod</code>, then paste the following command:</p>
<pre><code class="lang-bash">terraform plan
</code></pre>
<p>Once we have confirmed everything will deploy as expected, go ahead and run the apply:</p>
<pre><code class="lang-bash">terraform apply
</code></pre>
<p>When complete, you will now have two sets of environments deployed in your Azure Subscription, one for Development and one for Production.</p>
<p>This concludes the exercise. </p>
<div class="exercise-end"></div>


<h3 id="wrap-up">Wrap up</h3>
<p>Let&#39;s test our application...visit the Azure portal and verify that everything still works.</p>
<p>Congrats! You now have a functioning, secure web application using infrastructure as code with Terraform!</p>
<h3 id="future-direction">Future Direction</h3>
<p>Now that you&#39;ve reached the end of the workshop, where can yo go next? You could:</p>
<ol>
<li>try integrating your Terraform code into a CICD pipeline</li>
<li>explore other providers</li>
<li>try to declaratively describe an existing cloud environment </li>
<li>something else?</li>
</ol>
<p>Congrats! You&#39;re finished!</p>

			</div>
			<hr>
			<br />
			<br />
			<br />
			<br />
		</div>
	</div>
</div>

<script src="scripts/built.js"></script>

</body>
</html>